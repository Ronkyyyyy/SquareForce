<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQUARE FORCE - Dev Test</title>
    <style>
        :root {
            --bg-color: #121212;
            --grid-line: #333;
            --accent-color: #ff6600;
            --accent-glow: rgba(255, 102, 0, 0.5);
            --text-color: #e0e0e0;
            --player-bg: #1e1e1e;
            --info-color: #00d2ff;
            --danger-color: #ff0044;
            --heal-color: #00ff88;
            --team-red: #ff3333;
            --team-blue: #3333ff;
            --debug-bg: rgba(0, 50, 0, 0.95);
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        h1 {
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-glow);
            letter-spacing: 2px;
            margin: 10px 0;
            font-size: 1.5rem;
        }

        /* Layout */
        #game-container {
            display: grid;
            grid-template-areas:
                "log north info"
                "west board east"
                "west south east"
                "controls controls controls";
            grid-template-columns: 250px auto 250px;
            grid-template-rows: auto auto auto auto;
            gap: 10px;
            max-width: 1200px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            filter: blur(0px);
            transition: filter 0.5s;
        }
        
        #game-container.blur {
            filter: blur(5px);
            pointer-events: none;
        }

        /* Info Panel */
        #info-panel {
            grid-area: info;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 0.9rem;
        }
        .phase-badge {
            padding: 5px 10px;
            border: 1px solid #fff;
            margin-bottom: 5px;
            font-weight: bold;
            text-align: right;
            display: none;
        }
        .team-badge {
            padding: 5px 10px;
            margin-bottom: 5px;
            font-weight: bold;
            display: none;
        }
        .team-red { color: var(--team-red); border: 1px solid var(--team-red); }
        .team-blue { color: var(--team-blue); border: 1px solid var(--team-blue); }

        /* Board */
        #board-area {
            grid-area: board;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(7, 40px);
            grid-template-rows: repeat(7, 40px);
            gap: 2px;
            background-color: var(--grid-line);
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .cell {
            background-color: var(--bg-color);
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: #444;
            position: relative;
        }

        .cell.center {
            background-color: #2a1a10;
            border: 1px dashed var(--accent-color);
        }

        .core {
            width: 24px;
            height: 24px;
            background-color: var(--accent-color);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent-color), 0 0 20px white;
            z-index: 10;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        /* Player Areas */
        .player-zone {
            background-color: var(--player-bg);
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 120px;
            position: relative;
        }

        .player-zone.active {
            border-color: var(--accent-color);
            box-shadow: inset 0 0 10px var(--accent-glow);
        }

        /* Animation */
        .player-zone.damage-anim {
            animation: shake 0.5s;
            background-color: #330000;
        }
        .player-zone.heal-anim {
            animation: bounce 0.5s;
            background-color: #003311;
            box-shadow: inset 0 0 20px var(--heal-color);
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }


        #zone-north { grid-area: north; }
        #zone-south { grid-area: south; border-top: 2px solid var(--accent-color); }
        #zone-east { grid-area: east; writing-mode: vertical-rl; text-orientation: mixed; }
        #zone-west { grid-area: west; writing-mode: vertical-rl; text-orientation: mixed; }

        .p-name { font-weight: bold; color: var(--accent-color); margin-bottom: 5px; }
        .p-hp { font-size: 1.2rem; color: var(--danger-color); }
        .p-status { font-size: 0.8rem; color: #888; margin-bottom: 5px;}
        .p-card-display { 
            margin-top: 5px; 
            width: 40px; 
            height: 56px; 
            border: 1px dashed #555; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Controls */
        #controls-area {
            grid-area: controls;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #000;
            border-top: 1px solid var(--accent-color);
            width: 100%;
        }

        .phase-indicator {
            font-size: 1.1rem;
            color: var(--info-color);
            margin-bottom: 5px;
        }

        .hand-container {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .card {
            width: 50px;
            height: 70px;
            background: #222;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            user-select: none;
        }

        .card:hover {
            transform: translateY(-5px);
            background: #333;
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .card.selected {
            background: var(--accent-color);
            color: #000;
            transform: translateY(-10px);
        }

        .card.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        .card-back {
            background: repeating-linear-gradient(
                45deg,
                #222,
                #222 5px,
                #333 5px,
                #333 10px
            );
            color: transparent;
        }

        .action-btn {
            padding: 10px 30px;
            background: var(--accent-color);
            color: #000;
            border: none;
            font-weight: bold;
            font-family: inherit;
            cursor: pointer;
            margin-top: 10px;
            font-size: 1rem;
        }
        .action-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        /* Logs */
        #log-area {
            grid-area: log;
            background: #111;
            border: 1px solid #333;
            height: 200px;
            overflow-y: auto;
            padding: 5px;
            display: flex;
            flex-direction: column;
        }
        .log-msg { 
            font-size: 0.8rem; color: #aaa; margin-bottom: 4px; 
            border-left: 2px solid transparent; padding-left: 5px; 
        }
        .log-msg.sys { color: #888; font-style: italic; }
        .log-msg.dmg { color: var(--danger-color); border-left-color: var(--danger-color); }
        .log-msg.heal { color: var(--heal-color); border-left-color: var(--heal-color); }
        .log-msg.neg { color: var(--info-color); border-left-color: var(--info-color); }
        .log-msg.secret { color: #cc00ff; border-left-color: #cc00ff; }
        
        /* Overlays */
        #overlay-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #river-selection-area { display: none; flex-direction: column; align-items: center; }
        #river-cards { display: flex; gap: 20px; margin-top: 20px; }

        #insight-area { display: none; flex-direction: column; align-items: center; max-width: 400px; text-align: center; }
        #insight-btns { display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap; justify-content: center; }

        /* Setup Screen */
        #setup-screen { display: flex; flex-direction: column; gap: 15px; background: #222; padding: 30px; border: 2px solid var(--accent-color); box-shadow: 0 0 20px var(--accent-glow); max-width: 400px; width: 90%; }
        .setup-row { display: flex; justify-content: space-between; align-items: center; }
        .setup-label { color: var(--text-color); font-weight: bold; }
        select.setup-select { padding: 5px; width: 150px; border: 1px solid var(--accent-color); }
        input[type="checkbox"] { transform: scale(1.5); accent-color: var(--accent-color); }
        h2 { color: var(--accent-color); text-align: center; margin-top: 0;}
        .section-title { color: #888; border-bottom: 1px solid #444; margin-top: 10px; margin-bottom: 5px;}

        /* Debug Panel */
        #debug-btn {
            position: fixed; top: 10px; left: 10px; z-index: 200;
            background: #333; color: #0f0; border: 1px solid #0f0; padding: 5px 10px; cursor: pointer; font-size: 0.8rem;
        }
        #debug-panel {
            position: fixed; top: 40px; left: 10px; width: 300px; max-height: 80vh;
            background: var(--debug-bg); border: 1px solid #0f0; padding: 10px;
            display: none; flex-direction: column; gap: 10px; z-index: 200; overflow-y: auto;
            color: #0f0; font-family: monospace; font-size: 0.8rem;
        }
        .debug-row { display: flex; justify-content: space-between; align-items: center; }
        .debug-text { width: 100%; height: 100px; background: black; color: #0f0; border: 1px solid #555; font-size: 0.7rem; }
        button.dbg-btn { background: #004400; color: #0f0; border: 1px solid #0f0; cursor: pointer; padding: 2px 5px; }
        button.dbg-btn:hover { background: #006600; }

        @media (max-width: 768px) {
            #game-container {
                grid-template-areas:
                    "log"
                    "info"
                    "north"
                    "board"
                    "south"
                    "controls";
                grid-template-columns: 100%;
                grid-template-rows: auto;
            }
            #zone-east, #zone-west { display: none; }
            #grid { transform: scale(0.9); }
            #info-panel { align-items: center; }
            #debug-panel { width: 90%; }
        }

        /* Utility */
        .hidden { display: none !important; }
        .highlight-text { color: var(--accent-color); font-weight: bold; }
    </style>
</head>
<body>

    <button id="debug-btn" onclick="toggleDebug()">[DEBUG] MODE</button>
    <div id="debug-panel">
        <div style="font-weight:bold; border-bottom:1px solid #0f0; padding-bottom:5px;">DEVELOPER TOOLS</div>
        
        <div class="debug-row">
            <span>Auto Play (South AI):</span>
            <input type="checkbox" id="chk-autoplay">
        </div>
        <div class="debug-row">
            <span>High Speed Mode:</span>
            <input type="checkbox" id="chk-fastmode">
        </div>
        
        <div style="margin-top:10px;">Game Log (CSV):</div>
        <textarea id="debug-log-area" class="debug-text" readonly></textarea>
        <button class="dbg-btn" onclick="downloadCSV()">Download CSV</button>
        
        <div style="font-size:0.7rem; color:#aaa; margin-top:5px;">
            ※Excel等で分析可能。<br>Turn, Phase, Cards(N,E,S,W), Move(X,Y), HP(N,E,S,W)
        </div>
    </div>

    <h1>SQUARE FORCE</h1>

    <div id="overlay-container">
        <div id="setup-screen">
            <h2>MATCH CONFIG</h2>
            <div class="section-title">OPPONENTS</div>
            <div class="setup-row">
                <span class="setup-label">NORTH</span>
                <select id="sel-north" class="setup-select"></select>
            </div>
            <div class="setup-row">
                <span class="setup-label">EAST</span>
                <select id="sel-east" class="setup-select"></select>
            </div>
            <div class="setup-row">
                <span class="setup-label">WEST</span>
                <select id="sel-west" class="setup-select"></select>
            </div>

            <div class="section-title">MODULES</div>
            <div class="setup-row">
                <span class="setup-label">Core Shift (物理変化)</span>
                <input type="checkbox" id="chk-coreshift">
            </div>
            <div class="setup-row">
                <span class="setup-label">Alliance (チーム戦)</span>
                <input type="checkbox" id="chk-alliance" onchange="toggleBlind()">
            </div>
            <div class="setup-row" id="row-blind" style="opacity: 0.5;">
                <span class="setup-label">Blind Parade (正体不明)</span>
                <input type="checkbox" id="chk-blind" disabled>
            </div>

            <button class="action-btn" onclick="startGameFlow()">GAME START</button>
        </div>

        <div id="river-selection-area">
            <h2 style="color:white;">右のリバーから補充</h2>
            <div id="river-cards"></div>
        </div>

        <div id="insight-area">
            <h2 style="color:var(--info-color);">【インサイト】発動</h2>
            <p style="color:white;">ダメージの代償として情報を得ます。<br>誰の正体を確認しますか？</p>
            <div id="insight-btns"></div>
            <button class="small-btn" onclick="game.skipInsight()" style="margin-top:20px;">使用しない</button>
        </div>
    </div>

    <div id="game-container" class="blur">
        <div id="log-area">
            <div class="log-msg sys">システム: セットアップ待機中...</div>
        </div>

        <div id="info-panel">
            <div id="phase-badge" class="phase-badge" style="border-color: #555; color: #555;">Phase 1: STANDARD</div>
            <div id="team-badge" class="team-badge">TEAM: ???</div>
        </div>

        <div id="zone-north" class="player-zone">
            <div class="p-name">NORTH (COM)</div>
            <div class="p-status" id="status-0">Type: ???</div>
            <div class="p-hp" id="hp-0">HP: 10</div>
            <div class="p-card-display" id="disp-0">?</div>
        </div>

        <div id="zone-east" class="player-zone">
            <div class="p-name">EAST (COM)</div>
            <div class="p-status" id="status-1">Type: ???</div>
            <div class="p-hp" id="hp-1">HP: 10</div>
            <div class="p-card-display" id="disp-1">?</div>
        </div>

        <div id="zone-west" class="player-zone">
            <div class="p-name">WEST (COM)</div>
            <div class="p-status" id="status-3">Type: ???</div>
            <div class="p-hp" id="hp-3">HP: 10</div>
            <div class="p-card-display" id="disp-3">?</div>
        </div>

        <div id="board-area">
            <div id="grid">
                </div>
        </div>

        <div id="zone-south" class="player-zone active">
            <div class="p-name">SOUTH (YOU)</div>
            <div class="p-hp" id="hp-2">HP: 10</div>
            <div class="p-card-display" id="disp-2">?</div>
        </div>

        <div id="controls-area">
            <div class="phase-indicator" id="phase-text">Phase 1: チャージ（カード選択）</div>
            <div class="hand-container" id="hand-container">
                </div>
            <button id="main-action-btn" class="action-btn" onclick="game.confirmCard()" disabled>決定</button>
        </div>
    </div>

    <script>
        // --- Debug Functions ---
        function toggleDebug() {
            const panel = document.getElementById('debug-panel');
            panel.style.display = (panel.style.display === 'flex') ? 'none' : 'flex';
        }

        function downloadCSV() {
            const csvContent = document.getElementById('debug-log-area').value;
            if (!csvContent) { alert("ログがありません"); return; }
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `square_force_log_${new Date().toISOString().slice(0,19).replace(/[-T:]/g,"")}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- Game Constants & Logic ---
        const GRID_SIZE = 7;
        const CENTER = 3; 
        const PLAYER_NAMES = ['NORTH', 'EAST', 'SOUTH', 'WEST'];
        const COM_TYPES = [
            { id: 'RANDOM', name: 'ランダム (狂人)' },
            { id: 'AGGRO', name: '好戦的 (猛攻)' },
            { id: 'DEFENSE', name: '慎重派 (堅実)' },
            { id: 'REVENGE', name: '復讐者 (粘着)' },
            { id: 'BALANCED', name: 'バランス (策士)' }
        ];

        const DECK_COMPOSITION = {
            '0': 6, '1': 6, '2': 8, '3': 8, '4': 6, '5': 6, 'M': 8
        };

        const PHASES = [
            { id: 1, name: 'STANDARD', desc: '標準', color: '#00d2ff' },
            { id: 2, name: 'RAPID', desc: '加速 (移動+1)', color: '#ffff00' },
            { id: 3, name: 'HEAL', desc: '癒やし (辺落ち回復)', color: '#00ff88' },
            { id: 4, name: 'BOMB', desc: '爆発 (Dmg x2)', color: '#ff0000' }
        ];

        // --- Setup Logic ---
        function initSetup() {
            const selects = ['sel-north', 'sel-east', 'sel-west'];
            selects.forEach(id => {
                const sel = document.getElementById(id);
                COM_TYPES.forEach(type => {
                    const opt = document.createElement('option');
                    opt.value = type.id;
                    opt.textContent = type.name;
                    sel.appendChild(opt);
                });
                sel.value = COM_TYPES[Math.floor(Math.random() * COM_TYPES.length)].id;
            });
        }

        function toggleBlind() {
            const chkAll = document.getElementById('chk-alliance');
            const chkBlind = document.getElementById('chk-blind');
            const rowBlind = document.getElementById('row-blind');
            
            if (chkAll.checked) {
                chkBlind.disabled = false;
                rowBlind.style.opacity = 1.0;
            } else {
                chkBlind.checked = false;
                chkBlind.disabled = true;
                rowBlind.style.opacity = 0.5;
            }
        }

        function startGameFlow() {
            const config = {
                n: document.getElementById('sel-north').value,
                e: document.getElementById('sel-east').value,
                w: document.getElementById('sel-west').value,
                coreShift: document.getElementById('chk-coreshift').checked,
                alliance: document.getElementById('chk-alliance').checked,
                blind: document.getElementById('chk-blind').checked
            };

            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('overlay-container').style.display = 'none'; 
            document.getElementById('game-container').classList.remove('blur');

            game.startWithConfig(config);
        }

        class SquareForce {
            constructor() {
                // Initial state placeholders
                this.grid = [];
                this.corePos = { x: CENTER, y: CENTER };
                this.players = []; 
                this.rivers = [[], [], [], []]; 
                this.deck = [];
                this.phase = 'SETUP';
                this.gameConfig = {};
                this.currentPhaseIdx = 1; 
                this.teams = []; 
                this.pendingCards = [null, null, null, null]; 
                this.isProcessing = false;
                
                // Analytics
                this.turnCount = 1;
                this.historyCSV = "Turn,PhaseName,Card_N,Card_E,Card_S,Card_W,Move_X,Move_Y,HP_N,HP_E,HP_S,HP_W\n";
            }

            // --- Core Initialization ---
            startWithConfig(config) {
                this.resetGame();
                this.gameConfig = config;
                this.createDeck();
                this.setupPlayers(config);
                this.setupTeams();
                this.dealInitial();
                this.renderGrid();
                this.updateUI();
                
                this.log("＝＝ ゲーム開始 ＝＝", 'sys');
                if(this.gameConfig.coreShift) this.log("■拡張A: Core Shift [ON]", 'sys');
                if(this.gameConfig.alliance) this.log("■拡張B: Secret Alliance [ON]", 'sys');
                if(this.gameConfig.blind) this.log("■オプション: Blind Parade [ON]", 'sys');

                this.setPhase('CHARGE');
                
                // Init Log
                document.getElementById('debug-log-area').value = this.historyCSV;
                
                // Auto Play Trigger
                this.checkAutoPlay();
            }

            resetGame() {
                this.grid = [];
                this.corePos = { x: CENTER, y: CENTER };
                this.players = [];
                this.rivers = [[], [], [], []];
                this.deck = [];
                this.pendingCards = [null, null, null, null];
                this.teams = [];
                this.currentPhaseIdx = 1;
                this.isProcessing = false;
                this.turnCount = 1;
                this.historyCSV = "Turn,PhaseName,Card_N,Card_E,Card_S,Card_W,Move_X,Move_Y,HP_N,HP_E,HP_S,HP_W\n";
                
                document.getElementById('phase-badge').style.display = 'none';
                document.getElementById('team-badge').style.display = 'none';
                document.getElementById('log-area').innerHTML = '';
            }

            createDeck() {
                this.deck = [];
                for (let [val, count] of Object.entries(DECK_COMPOSITION)) {
                    for (let i = 0; i < count; i++) this.deck.push(val);
                }
                this.shuffle(this.deck);
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            setupPlayers(config) {
                const getTypeObj = (id) => COM_TYPES.find(t => t.id === id);
                const configs = [config.n, config.e, 'HUMAN', config.w];

                for (let i = 0; i < 4; i++) {
                    let typeObj = (i === 2) ? 'HUMAN' : getTypeObj(configs[i]);
                    if (!typeObj) typeObj = COM_TYPES[0]; 

                    this.players.push({
                        id: i,
                        name: PLAYER_NAMES[i],
                        hp: 10,
                        hand: [],
                        type: typeObj,
                        isDead: false
                    });
                    if (i !== 2) {
                        document.getElementById(`status-${i}`).textContent = `性格: ${typeObj.name}`;
                    }
                }
            }

            setupTeams() {
                if (!this.gameConfig.alliance) return;

                const t = [0, 0, 1, 1];
                this.shuffle(t);
                this.teams = t;
                const teamBadge = document.getElementById('team-badge');
                teamBadge.style.display = 'block';

                const myTeam = this.teams[2]; 
                const rightTeam = this.teams[1]; 

                if (this.gameConfig.blind) {
                    teamBadge.textContent = "YOU: ???";
                    teamBadge.className = "team-badge";
                    this.log(`【Blind Parade】あなたの正体は不明です。`);
                    this.log(`【Info】右隣(EAST)は「${rightTeam === 0 ? 'RED' : 'BLUE'}」チームです。`, 'secret');
                } else {
                    teamBadge.textContent = `YOU: ${myTeam === 0 ? 'RED' : 'BLUE'}`;
                    teamBadge.className = `team-badge ${myTeam === 0 ? 'team-red' : 'team-blue'}`;
                    this.log(`あなたは「${myTeam === 0 ? 'RED' : 'BLUE'}」チームです。味方を探してください。`, 'secret');
                }
            }

            dealInitial() {
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 3; j++) { if (this.deck.length > 0) this.rivers[i].push(this.deck.pop()); }
                }
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 5; j++) { if (this.deck.length > 0) this.players[i].hand.push(this.deck.pop()); }
                }
            }

            // --- Game Loop ---

            getSpeedDelay(baseTime) {
                const isFast = document.getElementById('chk-fastmode').checked;
                return isFast ? 100 : baseTime;
            }

            checkAutoPlay() {
                const isAuto = document.getElementById('chk-autoplay').checked;
                if(isAuto && this.phase === 'CHARGE' && !this.isProcessing) {
                    // Auto Select for South
                    setTimeout(() => {
                        const handSize = this.players[2].hand.length;
                        if(handSize > 0) {
                            const rIdx = Math.floor(Math.random() * handSize);
                            this.selectCard(rIdx);
                            this.confirmCard();
                        }
                    }, this.getSpeedDelay(500));
                }
            }

            setPhase(phase) {
                this.phase = phase;
                const phaseText = {
                    'CHARGE': 'Phase 1: チャージ（カード選択）',
                    'IMPACT': 'Phase 2: インパクト（移動計算）',
                    'RESOLVE': 'Phase 3: 結果処理',
                    'DRAFT': 'Phase 4: 補充（リバーから選択）'
                };
                document.getElementById('phase-text').textContent = phaseText[phase] || phase;
                
                // Update Phase Badge
                if (this.gameConfig.coreShift) {
                    const badge = document.getElementById('phase-badge');
                    badge.style.display = 'block';
                    const p = PHASES.find(x => x.id === this.currentPhaseIdx);
                    if (p) {
                        badge.textContent = `World: ${p.name} (${p.desc})`;
                        badge.style.color = p.color;
                        badge.style.borderColor = p.color;
                    }
                }

                if (phase === 'CHARGE') {
                    this.selectedCardIndex = -1;
                    this.renderHand();
                    this.resetDisplays();
                    document.getElementById('main-action-btn').disabled = true;
                    document.getElementById('main-action-btn').textContent = "決定";
                }
            }

            resetDisplays() {
                for(let i=0; i<4; i++) {
                    const el = document.getElementById(`disp-${i}`);
                    if(el) {
                        el.textContent = "?";
                        el.style.borderColor = "#555";
                        el.style.backgroundColor = "transparent";
                    }
                }
            }

            selectCard(index) {
                if (this.phase !== 'CHARGE' || this.isProcessing) return;
                this.selectedCardIndex = index;
                this.renderHand();
                document.getElementById('main-action-btn').disabled = false;
            }

            confirmCard() {
                if (this.selectedCardIndex === -1) return;
                const card = this.players[2].hand[this.selectedCardIndex];
                this.players[2].hand.splice(this.selectedCardIndex, 1);
                this.pendingCards[2] = card;
                this.decideCOMs();
                this.isProcessing = true;
                this.setPhase('IMPACT');
                this.renderHand();
                setTimeout(() => this.revealCards(), this.getSpeedDelay(500));
            }

            decideCOMs() {
                for (let i = 0; i < 4; i++) {
                    if (i === 2) continue; 
                    if (this.players[i].isDead) {
                        this.pendingCards[i] = '0'; 
                        continue;
                    }
                    const p = this.players[i];
                    const type = p.type.id;
                    const hand = p.hand;
                    let pickIndex = 0;
                    
                    pickIndex = Math.floor(Math.random() * hand.length); 
                    if (type === 'AGGRO') pickIndex = this.findCardIndex(hand, 'high');
                    else if (type === 'DEFENSE') pickIndex = this.findCardIndex(hand, 'low');
                    else if (type === 'BALANCED') pickIndex = this.findCardIndex(hand, 'mid');
                    
                    this.pendingCards[i] = hand[pickIndex];
                    p.hand.splice(pickIndex, 1);
                }
            }

            findCardIndex(hand, criteria) {
                let bestIdx = 0; let bestVal = -1; let lowestVal = 99;
                hand.forEach((c, i) => {
                    let val = (c === 'M') ? 0 : parseInt(c); 
                    if (criteria === 'high') { if (val > bestVal) { bestVal = val; bestIdx = i; } }
                    else if (criteria === 'low') { if (val < lowestVal) { lowestVal = val; bestIdx = i; } }
                    else { if (Math.abs(val - 2.5) < Math.abs(bestVal - 2.5)) { bestVal = val; bestIdx = i; } }
                });
                return bestIdx;
            }

            revealCards() {
                for (let i = 0; i < 4; i++) {
                    const el = document.getElementById(`disp-${i}`);
                    el.textContent = this.pendingCards[i];
                    if (this.pendingCards[i] === 'M') {
                        el.style.borderColor = "#d0f";
                        el.style.color = "#d0f";
                    } else {
                        el.style.borderColor = "#ff6600";
                        el.style.color = "#ff6600";
                    }
                }
                setTimeout(() => this.calculateImpact(), this.getSpeedDelay(1000));
            }

            calculateImpact() {
                const cards = this.pendingCards;
                let moveX = 0, moveY = 0;

                const getVal = (idx, oppIdx) => {
                    let c = cards[idx], opp = cards[oppIdx];
                    if (c === 'M' && opp === 'M') return 0;
                    if (c === 'M') return parseInt(opp);
                    return parseInt(c);
                };

                let valN = getVal(0, 2), valS = getVal(2, 0);
                let valE = getVal(1, 3), valW = getVal(3, 1);

                if (valN > valS) moveY = (valN - valS);
                else if (valS > valN) moveY = -(valS - valN);

                if (valW > valE) moveX = (valW - valE);
                else if (valE > valW) moveX = -(valE - valW);

                // --- Core Shift Logic ---
                if (this.gameConfig.coreShift) {
                    const phase = this.currentPhaseIdx;
                    if (phase === 2) { // RAPID
                        if (moveY > 0) moveY += 1;
                        else if (moveY < 0) moveY -= 1;
                        
                        if (moveX > 0) moveX += 1;
                        else if (moveX < 0) moveX -= 1;
                    } 
                }

                // --- RECORD LOG ---
                const phaseName = PHASES.find(p=>p.id===this.currentPhaseIdx)?.name || "UNK";
                const hpStr = this.players.map(p=>p.hp).join(",");
                const csvRow = `${this.turnCount},${phaseName},${cards[0]},${cards[1]},${cards[2]},${cards[3]},${moveX},${moveY},${hpStr}\n`;
                this.historyCSV += csvRow;
                document.getElementById('debug-log-area').value = this.historyCSV;
                this.turnCount++;

                this.log(`移動: Y${moveY}, X${moveX}`);

                if (moveX === 0 && moveY === 0) {
                    this.handleZeroImpact();
                } else {
                    this.moveCore(moveX, moveY);
                }
            }

            handleZeroImpact() {
                if (this.corePos.x === CENTER && this.corePos.y === CENTER) {
                    let dmg = 1;
                    if (this.gameConfig.coreShift && this.currentPhaseIdx === 4) dmg = 2; // BOMB
                    this.log(`【グラビティ・ショック】中心均衡！全員${dmg}ダメージ！`, 'dmg');
                    this.applyDamage([0,1,2,3], dmg);
                } else {
                    if (this.gameConfig.coreShift && this.currentPhaseIdx === 2) {
                        this.log("【RAPID】均衡（移動0）。ワープは発生しません。", 'neg');
                        setTimeout(() => this.phaseJudge(), this.getSpeedDelay(1000));
                    } else {
                        this.log("【ワープ】移動量0。反対側へ転移。", 'neg');
                        this.corePos.x = 6 - this.corePos.x;
                        this.corePos.y = 6 - this.corePos.y;
                        this.renderGrid();
                        setTimeout(() => this.phaseJudge(), this.getSpeedDelay(1000));
                    }
                }
            }

            moveCore(dx, dy) {
                this.corePos.x += dx;
                this.corePos.y += dy;
                this.renderGrid();
                setTimeout(() => this.phaseJudge(), this.getSpeedDelay(1000));
            }

            phaseJudge() {
                const x = this.corePos.x, y = this.corePos.y;
                let victims = [], damage = 0, isOut = false;
                
                let outN = y < 0, outS = y > 6, outW = x < 0, outE = x > 6;

                if (outN || outS || outW || outE) {
                    isOut = true;
                    let mult = 1;
                    let isHeal = false;

                    if (this.gameConfig.coreShift) {
                        if (this.currentPhaseIdx === 4) mult = 2; // BOMB
                        if (this.currentPhaseIdx === 3) isHeal = true; // HEAL
                    }

                    if ((outN || outS) && (outW || outE)) {
                        if (isHeal) {
                            damage = 0;
                            if(outN && outW) victims = [0, 3];
                            if(outN && outE) victims = [0, 1];
                            if(outS && outW) victims = [2, 3];
                            if(outS && outE) victims = [2, 1];
                            this.log(`【HEAL】角落ち：両者ダメージなし(±0)`, 'heal');
                        } else {
                            damage = 1 * mult;
                            if(outN && outW) victims = [0, 3];
                            if(outN && outE) victims = [0, 1];
                            if(outS && outW) victims = [2, 3];
                            if(outS && outE) victims = [2, 1];
                            this.log(`【コーナー落ち】${victims.map(i=>PLAYER_NAMES[i]).join('&')}に${damage}ダメージ`, 'dmg');
                        }
                    } else {
                        if (isHeal) {
                            damage = -1; // Heal
                            if(outN) victims = [0];
                            if(outS) victims = [2];
                            if(outW) victims = [3];
                            if(outE) victims = [1];
                            this.log(`【HEAL】辺落ち：${PLAYER_NAMES[victims[0]]}はHP回復(+1)`, 'heal');
                        } else {
                            damage = 2 * mult;
                            if(outN) victims = [0];
                            if(outS) victims = [2];
                            if(outW) victims = [3];
                            if(outE) victims = [1];
                            this.log(`【サイド落ち】${PLAYER_NAMES[victims[0]]}に${damage}ダメージ`, 'dmg');
                        }
                    }
                }

                if (isOut) {
                    if (this.gameConfig.coreShift) {
                        this.currentPhaseIdx = (this.currentPhaseIdx % 4) + 1;
                        this.log(`>> 世界改変: Phase ${this.currentPhaseIdx}へ移行`, 'sys');
                    }
                    this.applyDamage(victims, damage);
                } else {
                    setTimeout(() => this.phaseCleanup(), this.getSpeedDelay(1000));
                }
            }

            applyDamage(indices, amount) {
                let humanDamaged = false;
                indices.forEach(i => {
                    this.players[i].hp -= amount;
                    if (this.players[i].hp > 10) this.players[i].hp = 10;
                    
                    const zone = document.getElementById(i === 0 ? 'zone-north' : i===1 ? 'zone-east' : i===2 ? 'zone-south' : 'zone-west');
                    
                    if (amount > 0) {
                        zone.classList.add('damage-anim');
                        setTimeout(()=>zone.classList.remove('damage-anim'), 500);
                        if (i === 2) humanDamaged = true;
                    } else if (amount < 0) {
                        zone.classList.add('heal-anim');
                        setTimeout(()=>zone.classList.remove('heal-anim'), 500);
                    }
                });
                
                this.corePos = { x: CENTER, y: CENTER };
                this.renderGrid();
                this.updateUI();

                if (this.checkGameOver()) return;

                if (this.gameConfig.alliance && humanDamaged) {
                    const isAuto = document.getElementById('chk-autoplay').checked;
                    if(isAuto) {
                        // Skip insight if auto
                        setTimeout(() => this.phaseCleanup(), this.getSpeedDelay(800));
                    } else {
                        setTimeout(() => this.triggerInsight(), 800);
                    }
                } else {
                    setTimeout(() => this.phaseCleanup(), this.getSpeedDelay(1000));
                }
            }

            triggerInsight() {
                const overlay = document.getElementById('overlay-container');
                const insightArea = document.getElementById('insight-area');
                const btns = document.getElementById('insight-btns');
                btns.innerHTML = '';
                
                if (this.gameConfig.blind) {
                    const btn = document.createElement('button');
                    btn.className = 'action-btn';
                    btn.textContent = "自分の正体を思い出す";
                    btn.onclick = () => {
                        const myTeam = this.teams[2];
                        this.log(`【覚醒】あなたの正体は「${myTeam === 0 ? 'RED' : 'BLUE'}」チームでした。`, 'secret');
                        document.getElementById('team-badge').textContent = `YOU: ${myTeam === 0 ? 'RED' : 'BLUE'}`;
                        document.getElementById('team-badge').className = `team-badge ${myTeam === 0 ? 'team-red' : 'team-blue'}`;
                        this.endInsight();
                    };
                    btns.appendChild(btn);
                } else {
                    [0, 1, 3].forEach(idx => {
                        const btn = document.createElement('button');
                        btn.className = 'action-btn';
                        btn.textContent = `${PLAYER_NAMES[idx]}を見る`;
                        btn.onclick = () => {
                            const t = this.teams[idx];
                            this.log(`【インサイト】${PLAYER_NAMES[idx]}は「${t === 0 ? 'RED' : 'BLUE'}」チームです。`, 'secret');
                            this.endInsight();
                        };
                        btns.appendChild(btn);
                    });
                }

                overlay.style.display = 'flex';
                insightArea.style.display = 'flex';
                document.getElementById('river-selection-area').style.display = 'none';
            }

            skipInsight() { this.endInsight(); }
            endInsight() {
                document.getElementById('overlay-container').style.display = 'none';
                document.getElementById('insight-area').style.display = 'none';
                this.phaseCleanup();
            }

            checkGameOver() {
                const dead = this.players.filter(p => p.hp <= 0);
                if (dead.length > 0) {
                    let msg = "";
                    if (this.gameConfig.alliance) {
                        const deadPlayer = dead[0];
                        const deadTeam = this.teams[deadPlayer.id];
                        const winTeamName = (deadTeam === 0) ? 'BLUE' : 'RED';
                        msg = `GAME SET!\n脱落者: ${deadPlayer.name} (Team ${deadTeam===0?'RED':'BLUE'})\n勝者: ${winTeamName} TEAM`;
                    } else {
                        let maxHp = -99;
                        let winner = [];
                        this.players.forEach(p => {
                            if (p.hp > maxHp) { maxHp = p.hp; winner = [p.name]; } 
                            else if (p.hp === maxHp) { winner.push(p.name); }
                        });
                        msg = `GAME SET!\nWinner: ${winner.join(', ')}`;
                    }

                    // AutoPlay Handling: Don't show Alert if Auto?
                    // For now, let's just log and reload if auto
                    const isAuto = document.getElementById('chk-autoplay').checked;
                    if(isAuto) {
                        console.log(msg); // Console log
                        this.historyCSV += `\n--- GAME OVER ---\n${msg}`;
                        document.getElementById('debug-log-area').value = this.historyCSV;
                        // Don't auto-reload to keep logs visible.
                        // User can restart manually.
                    } else {
                        alert(msg);
                        location.reload();
                    }
                    return true;
                }
                return false;
            }

            phaseCleanup() {
                const getLeftRiverIdx = (i) => (i + 3) % 4;
                for (let i = 0; i < 4; i++) {
                    const card = this.pendingCards[i];
                    const leftRIdx = getLeftRiverIdx(i);
                    if (card === 'M') {
                        if (this.deck.length > 0) this.rivers[leftRIdx].push(this.deck.pop());
                    } else {
                        this.rivers[leftRIdx].push(card);
                    }
                }
                this.startDraftPhase();
            }

            startDraftPhase() {
                this.setPhase('DRAFT');
                
                // Draw logic
                [0, 1, 3].forEach(i => {
                    const drawRiverIdx = (i + 3) % 4;
                    const river = this.rivers[drawRiverIdx];
                    if (river.length > 0) {
                        const rIdx = Math.floor(Math.random() * river.length);
                        this.players[i].hand.push(river.splice(rIdx, 1)[0]);
                    }
                });

                const myDrawRiverIdx = (2 + 3) % 4; 
                const myRiver = this.rivers[myDrawRiverIdx];
                
                if (myRiver.length === 0) {
                    this.log("リバー枯渇。補充なし。");
                    this.finishTurn();
                } else {
                    const isAuto = document.getElementById('chk-autoplay').checked;
                    if(isAuto) {
                         const rIdx = Math.floor(Math.random() * myRiver.length);
                         const drawn = myRiver.splice(rIdx, 1)[0];
                         this.players[2].hand.push(drawn);
                         this.log(`[AUTO] カード補充完了。`);
                         this.finishTurn();
                    } else {
                        this.showRiverSelection(myRiver);
                    }
                }
            }

            showRiverSelection(river) {
                const overlay = document.getElementById('overlay-container');
                const riverArea = document.getElementById('river-selection-area');
                const riverCardsDiv = document.getElementById('river-cards');
                
                overlay.style.display = 'flex';
                riverArea.style.display = 'flex';
                riverCardsDiv.innerHTML = '';
                
                river.forEach((card, index) => {
                    const el = document.createElement('div');
                    el.className = 'card card-back';
                    el.onclick = () => {
                        const drawn = river.splice(index, 1)[0];
                        this.players[2].hand.push(drawn);
                        this.log(`カード補充完了。`);
                        overlay.style.display = 'none';
                        riverArea.style.display = 'none';
                        this.finishTurn();
                    };
                    riverCardsDiv.appendChild(el);
                });
            }

            finishTurn() {
                this.isProcessing = false;
                this.setPhase('CHARGE');
                this.updateUI();
                this.checkAutoPlay();
            }

            log(msg, type='') {
                const log = document.getElementById('log-area');
                const div = document.createElement('div');
                div.className = `log-msg ${type}`;
                div.textContent = msg;
                log.appendChild(div);
                log.scrollTop = log.scrollHeight;
            }
        }

        const game = new SquareForce();
        initSetup();

    </script>
</body>
</html>
