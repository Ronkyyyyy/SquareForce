<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQUARE FORCE - Web Edition</title>
    <style>
        :root {
            --bg-color: #121212;
            --grid-line: #333;
            --accent-color: #ff6600;
            --accent-glow: rgba(255, 102, 0, 0.5);
            --text-color: #e0e0e0;
            --player-bg: #1e1e1e;
            --info-color: #00d2ff;
            --danger-color: #ff0044;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        h1 {
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-glow);
            letter-spacing: 2px;
            margin: 10px 0;
            font-size: 1.5rem;
        }

        /* Layout */
        #game-container {
            display: grid;
            grid-template-areas:
                "chat north info"
                "west board east"
                "west south east"
                "controls controls controls";
            grid-template-columns: 250px auto 250px;
            grid-template-rows: auto auto auto auto;
            gap: 10px;
            max-width: 1200px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            filter: blur(0px);
            transition: filter 0.5s;
        }
        
        #game-container.blur {
            filter: blur(5px);
            pointer-events: none;
        }

        /* Board */
        #board-area {
            grid-area: board;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(7, 40px);
            grid-template-rows: repeat(7, 40px);
            gap: 2px;
            background-color: var(--grid-line);
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .cell {
            background-color: var(--bg-color);
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: #444;
            position: relative;
        }

        .cell.center {
            background-color: #2a1a10;
            border: 1px dashed var(--accent-color);
        }

        .core {
            width: 24px;
            height: 24px;
            background-color: var(--accent-color);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent-color), 0 0 20px white;
            z-index: 10;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        /* Player Areas */
        .player-zone {
            background-color: var(--player-bg);
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 120px;
            position: relative;
        }

        .player-zone.active {
            border-color: var(--accent-color);
            box-shadow: inset 0 0 10px var(--accent-glow);
        }

        .player-zone.damage-anim {
            animation: shake 0.5s;
            background-color: #330000;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        #zone-north { grid-area: north; }
        #zone-south { grid-area: south; border-top: 2px solid var(--accent-color); }
        #zone-east { grid-area: east; writing-mode: vertical-rl; text-orientation: mixed; }
        #zone-west { grid-area: west; writing-mode: vertical-rl; text-orientation: mixed; }

        .p-name { font-weight: bold; color: var(--accent-color); margin-bottom: 5px; }
        .p-hp { font-size: 1.2rem; color: var(--danger-color); }
        .p-status { font-size: 0.8rem; color: #888; margin-bottom: 5px;}
        .p-card-display { 
            margin-top: 5px; 
            width: 40px; 
            height: 56px; 
            border: 1px dashed #555; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Controls */
        #controls-area {
            grid-area: controls;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #000;
            border-top: 1px solid var(--accent-color);
            width: 100%;
        }

        .phase-indicator {
            font-size: 1.1rem;
            color: var(--info-color);
            margin-bottom: 5px;
        }

        .hand-container {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .card {
            width: 50px;
            height: 70px;
            background: #222;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            user-select: none;
        }

        .card:hover {
            transform: translateY(-5px);
            background: #333;
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .card.selected {
            background: var(--accent-color);
            color: #000;
            transform: translateY(-10px);
        }

        .card.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        .card-back {
            background: repeating-linear-gradient(
                45deg,
                #222,
                #222 5px,
                #333 5px,
                #333 10px
            );
            color: transparent;
        }

        .action-btn {
            padding: 10px 30px;
            background: var(--accent-color);
            color: #000;
            border: none;
            font-weight: bold;
            font-family: inherit;
            cursor: pointer;
            margin-top: 10px;
            font-size: 1rem;
        }
        .action-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        /* Chat & Logs */
        #chat-area {
            grid-area: chat;
            background: #111;
            border: 1px solid #333;
            height: 200px;
            display: flex;
            flex-direction: column;
        }
        #chat-log {
            flex: 1;
            overflow-y: auto;
            padding: 5px;
            font-size: 0.8rem;
            color: #aaa;
        }
        .chat-msg { margin-bottom: 4px; border-left: 2px solid transparent; padding-left: 5px; }
        .chat-msg.sys { color: #888; font-style: italic; }
        .chat-msg.dmg { color: var(--danger-color); border-left-color: var(--danger-color); }
        .chat-msg.neg { color: var(--info-color); border-left-color: var(--info-color); }
        
        #chat-controls {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 2px;
            background: #222;
        }
        select, button.small-btn {
            background: #000;
            color: #fff;
            border: 1px solid #555;
            padding: 2px;
            font-family: inherit;
            font-size: 0.8rem;
        }

        /* Overlays */
        #overlay-container {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        /* River Selection */
        #river-selection-area { display: none; flex-direction: column; align-items: center; }
        #river-cards { display: flex; gap: 20px; margin-top: 20px; }

        /* Setup Screen */
        #setup-screen { display: flex; flex-direction: column; gap: 15px; background: #222; padding: 30px; border: 2px solid var(--accent-color); box-shadow: 0 0 20px var(--accent-glow); max-width: 400px; width: 90%; }
        .setup-row { display: flex; justify-content: space-between; align-items: center; }
        .setup-label { color: var(--text-color); font-weight: bold; }
        select.setup-select { padding: 5px; width: 150px; border: 1px solid var(--accent-color); }
        h2 { color: var(--accent-color); text-align: center; margin-top: 0;}

        @media (max-width: 768px) {
            #game-container {
                grid-template-areas:
                    "chat"
                    "north"
                    "board"
                    "south"
                    "controls";
                grid-template-columns: 100%;
                grid-template-rows: auto;
            }
            #zone-east, #zone-west { display: none; } /* Simplified view for mobile if needed, or re-layout */
            /* Force showing simple bars for E/W on mobile */
            #grid { transform: scale(0.9); }
        }

        /* Utility */
        .hidden { display: none !important; }
        .highlight-text { color: var(--accent-color); font-weight: bold; }
        .bubble {
            position: absolute;
            background: white;
            color: black;
            padding: 5px;
            border-radius: 5px;
            font-size: 0.7rem;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .bubble.show { opacity: 1; }
    </style>
</head>
<body>

    <h1>SQUARE FORCE</h1>

    <div id="overlay-container">
        <div id="setup-screen">
            <h2>MATCH SETUP</h2>
            <div class="setup-row">
                <span class="setup-label">NORTH (上)</span>
                <select id="sel-north" class="setup-select"></select>
            </div>
            <div class="setup-row">
                <span class="setup-label">EAST (右)</span>
                <select id="sel-east" class="setup-select"></select>
            </div>
            <div class="setup-row">
                <span class="setup-label">WEST (左)</span>
                <select id="sel-west" class="setup-select"></select>
            </div>
            <div style="font-size: 0.8rem; color:#888; margin-top:10px;">
                ※SOUTH(あなた)は固定です
            </div>
            <button class="action-btn" onclick="startGameFlow()">GAME START</button>
        </div>

        <div id="river-selection-area">
            <h2 style="color:white;">右のリバーから補充 (選択)</h2>
            <div id="river-cards"></div>
        </div>
    </div>

    <div id="game-container" class="blur">
        <div id="chat-area">
            <div id="chat-log">
                <div class="chat-msg sys">システム: セットアップ待機中...</div>
            </div>
            <div id="chat-controls">
                <div style="display:flex; gap:2px;">
                    <select id="chat-target">
                        <option value="ALL">全員へ</option>
                        <option value="0">北へ</option>
                        <option value="1">東へ</option>
                        <option value="3">西へ</option>
                    </select>
                    <select id="chat-msg-select" style="flex:1;">
                        <option value="攻めよう">〇〇を攻めよう</option>
                        <option value="助けて">助けて！</option>
                        <option value="ごめん">ごめん</option>
                        <option value="Mあり">M持ってる</option>
                        <option value="お返し">お返しだ</option>
                        <option value="様子見">様子を見よう</option>
                    </select>
                    <button class="small-btn" onclick="game.sendChat()">発言</button>
                </div>
            </div>
        </div>

        <div id="zone-north" class="player-zone">
            <div class="p-name">NORTH (COM)</div>
            <div class="p-status" id="status-0">Type: ???</div>
            <div class="p-hp" id="hp-0">HP: 10</div>
            <div class="p-card-display" id="disp-0">?</div>
            <div class="bubble" id="bubble-0"></div>
        </div>

        <div id="zone-east" class="player-zone">
            <div class="p-name">EAST (COM)</div>
            <div class="p-status" id="status-1">Type: ???</div>
            <div class="p-hp" id="hp-1">HP: 10</div>
            <div class="p-card-display" id="disp-1">?</div>
            <div class="bubble" id="bubble-1"></div>
        </div>

        <div id="zone-west" class="player-zone">
            <div class="p-name">WEST (COM)</div>
            <div class="p-status" id="status-3">Type: ???</div>
            <div class="p-hp" id="hp-3">HP: 10</div>
            <div class="p-card-display" id="disp-3">?</div>
            <div class="bubble" id="bubble-3"></div>
        </div>

        <div id="board-area">
            <div id="grid">
                </div>
        </div>

        <div id="zone-south" class="player-zone active">
            <div class="p-name">SOUTH (YOU)</div>
            <div class="p-hp" id="hp-2">HP: 10</div>
            <div class="p-card-display" id="disp-2">?</div>
            <div class="bubble" id="bubble-2"></div>
        </div>

        <div id="controls-area">
            <div class="phase-indicator" id="phase-text">Phase 1: チャージ（カード選択）</div>
            <div class="hand-container" id="hand-container">
                </div>
            <button id="main-action-btn" class="action-btn" onclick="game.confirmCard()" disabled>決定</button>
        </div>
    </div>

    <script>
        // --- Game Constants & Logic ---
        const GRID_SIZE = 7;
        const CENTER = 3; 
        const DIRECTIONS = ['N', 'E', 'S', 'W'];
        const PLAYER_NAMES = ['NORTH', 'EAST', 'SOUTH', 'WEST'];
        const COM_TYPES = [
            { id: 'RANDOM', name: 'ランダム (狂人)', desc: '予測不能' },
            { id: 'AGGRO', name: '好戦的 (猛攻)', desc: 'ガンガン攻める' },
            { id: 'DEFENSE', name: '慎重派 (堅実)', desc: '守り重視' },
            { id: 'REVENGE', name: '復讐者 (粘着)', desc: 'やられたらやり返す' },
            { id: 'BALANCED', name: 'バランス (策士)', desc: '状況に合わせる' }
        ];

        // Card Definitions
        const DECK_COMPOSITION = {
            '0': 6, '1': 6, '2': 8, '3': 8, '4': 6, '5': 6, 'M': 8
        };

        // --- Setup Logic ---
        function initSetup() {
            const selects = ['sel-north', 'sel-east', 'sel-west'];
            selects.forEach(id => {
                const sel = document.getElementById(id);
                COM_TYPES.forEach(type => {
                    const opt = document.createElement('option');
                    opt.value = type.id;
                    opt.textContent = type.name;
                    sel.appendChild(opt);
                });
                // Set default random selections
                sel.value = COM_TYPES[Math.floor(Math.random() * COM_TYPES.length)].id;
            });
        }

        function startGameFlow() {
            const nType = document.getElementById('sel-north').value;
            const eType = document.getElementById('sel-east').value;
            const wType = document.getElementById('sel-west').value;

            // Hide setup, show game
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('overlay-container').style.display = 'none'; // Temporarily hide container
            document.getElementById('game-container').classList.remove('blur');

            game.startWithConfig({ n: nType, e: eType, w: wType });
        }

        class SquareForce {
            constructor() {
                this.grid = [];
                this.corePos = { x: CENTER, y: CENTER };
                this.players = []; 
                this.rivers = [[], [], [], []]; 
                this.deck = [];
                this.phase = 'SETUP';
                this.turnCount = 1;
                this.selectedCardIndex = -1;
                this.pendingCards = [null, null, null, null]; 
                this.lastDamageSource = [null, null, null, null]; 
                this.isProcessing = false;
            }

            startWithConfig(config) {
                this.createDeck();
                this.setupPlayers(config);
                this.dealInitial();
                this.renderGrid();
                this.updateUI();
                this.log("システム起動。戦闘シーケンスを開始します。", 'sys');
                this.setPhase('CHARGE');
            }

            createDeck() {
                this.deck = [];
                for (let [val, count] of Object.entries(DECK_COMPOSITION)) {
                    for (let i = 0; i < count; i++) this.deck.push(val);
                }
                this.shuffle(this.deck);
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            setupPlayers(config) {
                // 0:N, 1:E, 3:W are COM. 2:S is Human.
                const getTypeObj = (id) => COM_TYPES.find(t => t.id === id);
                
                const configs = [config.n, config.e, 'HUMAN', config.w];

                for (let i = 0; i < 4; i++) {
                    let typeId = configs[i];
                    let typeObj = (i === 2) ? 'HUMAN' : getTypeObj(typeId);

                    this.players.push({
                        id: i,
                        name: PLAYER_NAMES[i],
                        hp: 10,
                        hand: [],
                        type: typeObj,
                        isDead: false
                    });
                    
                    if (i !== 2) {
                        document.getElementById(`status-${i}`).textContent = `性格: ${typeObj.name}`;
                    }
                }
            }

            dealInitial() {
                // 1. Rivers: 3 cards each
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (this.deck.length > 0) this.rivers[i].push(this.deck.pop());
                    }
                }
                // 2. Hands: 5 cards each
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 5; j++) {
                        if (this.deck.length > 0) this.players[i].hand.push(this.deck.pop());
                    }
                }
            }

            // --- Game Loop Phases ---

            setPhase(phase) {
                this.phase = phase;
                const phaseText = {
                    'CHARGE': 'Phase 1: チャージ（カードを選べ）',
                    'IMPACT': 'Phase 2: インパクト（移動計算）',
                    'RESOLVE': 'Phase 3: 結果処理',
                    'DRAFT': 'Phase 4: 補充（リバーから選択）'
                };
                document.getElementById('phase-text').textContent = phaseText[phase] || phase;
                
                if (phase === 'CHARGE') {
                    this.selectedCardIndex = -1;
                    this.renderHand();
                    this.resetDisplays();
                    document.getElementById('main-action-btn').disabled = true;
                    document.getElementById('main-action-btn').textContent = "決定";
                }
            }

            resetDisplays() {
                for(let i=0; i<4; i++) {
                    document.getElementById(`disp-${i}`).textContent = "?";
                    document.getElementById(`disp-${i}`).style.borderColor = "#555";
                    document.getElementById(`disp-${i}`).style.backgroundColor = "transparent";
                }
            }

            // Human Interaction
            selectCard(index) {
                if (this.phase !== 'CHARGE' || this.isProcessing) return;
                this.selectedCardIndex = index;
                this.renderHand();
                document.getElementById('main-action-btn').disabled = false;
            }

            confirmCard() {
                if (this.selectedCardIndex === -1) return;
                
                // Human plays
                const card = this.players[2].hand[this.selectedCardIndex];
                this.players[2].hand.splice(this.selectedCardIndex, 1);
                this.pendingCards[2] = card;
                
                // COMs play
                this.decideCOMs();

                // Proceed
                this.isProcessing = true;
                this.setPhase('IMPACT');
                this.renderHand(); // Hide used card
                
                // Animation delay
                setTimeout(() => this.revealCards(), 500);
            }

            // AI Logic
            decideCOMs() {
                for (let i = 0; i < 4; i++) {
                    if (i === 2) continue; // Skip human
                    if (this.players[i].isDead) {
                        this.pendingCards[i] = '0'; // Dummy
                        continue;
                    }
                    
                    const p = this.players[i];
                    const hand = p.hand;
                    let pickIndex = 0;

                    // Simple Heuristics based on Type
                    const type = p.type.id;
                    const oppIdx = (i + 2) % 4; // Facing opponent
                    
                    let distToMe = 0;
                    if (i===0) distToMe = this.corePos.y; // N
                    if (i===1) distToMe = 6 - this.corePos.x; // E
                    if (i===2) distToMe = 6 - this.corePos.y; // S
                    if (i===3) distToMe = this.corePos.x; // W

                    // Chat chance
                    if (Math.random() < 0.2) this.triggerCOMChat(i, distToMe);

                    if (type === 'RANDOM') {
                        pickIndex = Math.floor(Math.random() * hand.length);
                    } else if (type === 'AGGRO') {
                        pickIndex = this.findCardIndex(hand, 'high');
                    } else if (type === 'DEFENSE') {
                        if (distToMe < 3) pickIndex = this.findCardIndex(hand, 'high');
                        else pickIndex = this.findCardIndex(hand, 'low');
                    } else if (type === 'REVENGE') {
                        const enemy = this.lastDamageSource[i];
                        if (enemy === oppIdx) pickIndex = this.findCardIndex(hand, 'high');
                        else pickIndex = this.findCardIndex(hand, 'mid');
                    } else {
                        // BALANCED
                        if (distToMe < 3) pickIndex = this.findCardIndex(hand, 'high');
                        else if (distToMe > 4) pickIndex = this.findCardIndex(hand, 'low'); 
                        else pickIndex = this.findCardIndex(hand, 'mid');
                    }

                    this.pendingCards[i] = hand[pickIndex];
                    p.hand.splice(pickIndex, 1);
                }
            }

            triggerCOMChat(idx, dist) {
                const p = this.players[idx];
                const type = p.type.id;
                let msg = "";

                if (dist <= 1) {
                    msg = "助けて";
                } else if (p.hp < 3) {
                    msg = "ごめん";
                } else if (type === 'AGGRO') {
                    msg = "攻めよう";
                } else if (this.pendingCards[idx] === 'M') {
                    msg = "Mあり";
                } else if (type === 'REVENGE') {
                    msg = "お返し";
                }

                if (msg) this.showBubble(idx, msg);
            }

            findCardIndex(hand, criteria) {
                let bestIdx = 0;
                let bestVal = -1;
                let lowestVal = 99;

                hand.forEach((c, i) => {
                    let val = (c === 'M') ? 0 : parseInt(c); 
                    if (criteria === 'high') {
                        if (val > bestVal) { bestVal = val; bestIdx = i; }
                    } else if (criteria === 'low') {
                        if (val < lowestVal) { lowestVal = val; bestIdx = i; }
                    } else {
                        // Mid
                        if (Math.abs(val - 2.5) < Math.abs(bestVal - 2.5)) { bestVal = val; bestIdx = i; }
                    }
                    if (c === 'M' && Math.random() < 0.3) bestIdx = i;
                });
                return bestIdx;
            }

            // Phase 2: Reveal & Calculate
            revealCards() {
                for (let i = 0; i < 4; i++) {
                    const el = document.getElementById(`disp-${i}`);
                    el.textContent = this.pendingCards[i];
                    if (this.pendingCards[i] === 'M') {
                        el.style.borderColor = "#d0f";
                        el.style.color = "#d0f";
                    } else {
                        el.style.borderColor = "#ff6600";
                        el.style.color = "#ff6600";
                    }
                }
                
                setTimeout(() => this.calculateImpact(), 1000);
            }

            calculateImpact() {
                const cards = this.pendingCards;
                let moveX = 0;
                let moveY = 0;

                const getVal = (idx, oppIdx) => {
                    let c = cards[idx];
                    let opp = cards[oppIdx];
                    if (c === 'M' && opp === 'M') return 0; // M vs M = 0
                    if (c === 'M') return parseInt(opp); // Copy
                    return parseInt(c);
                };

                let valN = getVal(0, 2);
                let valS = getVal(2, 0);
                let valE = getVal(1, 3);
                let valW = getVal(3, 1);

                if (valN > valS) moveY = (valN - valS);
                else if (valS > valN) moveY = -(valS - valN);

                if (valW > valE) moveX = (valW - valE);
                else if (valE > valW) moveX = -(valE - valW);

                this.log(`移動計算: N${valN}vsS${valS} (Y:${moveY}), W${valW}vsE${valE} (X:${moveX})`);

                if (moveX === 0 && moveY === 0) {
                    this.handleZeroImpact();
                } else {
                    this.moveCore(moveX, moveY);
                }
            }

            handleZeroImpact() {
                if (this.corePos.x === CENTER && this.corePos.y === CENTER) {
                    this.log("【グラビティ・ショック】中心均衡！全員1ダメージ！", 'dmg');
                    this.applyDamage([0,1,2,3], 1);
                    setTimeout(() => this.phaseJudge(), 1000);
                } else {
                    this.log("【ワープ】移動量0。反対側へ転移します。", 'neg');
                    const newX = 6 - this.corePos.x;
                    const newY = 6 - this.corePos.y;
                    this.corePos.x = newX;
                    this.corePos.y = newY;
                    this.renderGrid();
                    setTimeout(() => this.phaseJudge(), 1000);
                }
            }

            moveCore(dx, dy) {
                this.corePos.x += dx;
                this.corePos.y += dy;
                this.renderGrid();
                setTimeout(() => this.phaseJudge(), 1000);
            }

            // Phase 4: Judge
            phaseJudge() {
                const x = this.corePos.x;
                const y = this.corePos.y;
                let victims = [];
                let damage = 0;
                let isOut = false;
                
                let outN = y < 0;
                let outS = y > 6;
                let outW = x < 0;
                let outE = x > 6;

                if (outN || outS || outW || outE) {
                    isOut = true;
                    if ((outN || outS) && (outW || outE)) {
                        damage = 1;
                        if(outN && outW) victims = [0, 3];
                        if(outN && outE) victims = [0, 1];
                        if(outS && outW) victims = [2, 3];
                        if(outS && outE) victims = [2, 1];
                        this.log(`【コーナー落ち】${victims.map(i=>PLAYER_NAMES[i]).join('&')}に1ダメージ`, 'dmg');
                    } else {
                        damage = 2;
                        if(outN) victims = [0];
                        if(outS) victims = [2];
                        if(outW) victims = [3];
                        if(outE) victims = [1];
                        this.log(`【サイド落ち】${PLAYER_NAMES[victims[0]]}に2ダメージ`, 'dmg');
                    }
                }

                if (isOut) {
                    this.applyDamage(victims, damage);
                    this.corePos = { x: CENTER, y: CENTER };
                    this.renderGrid();
                }

                setTimeout(() => this.phaseCleanup(), 1000);
            }

            applyDamage(indices, amount) {
                indices.forEach(i => {
                    this.players[i].hp -= amount;
                    this.lastDamageSource[i] = -1; 
                    const zone = document.getElementById(i === 0 ? 'zone-north' : i===1 ? 'zone-east' : i===2 ? 'zone-south' : 'zone-west');
                    zone.classList.add('damage-anim');
                    setTimeout(()=>zone.classList.remove('damage-anim'), 500);
                });
                this.updateUI();
                this.checkGameOver();
            }

            checkGameOver() {
                if (this.players.some(p => p.hp <= 0)) {
                    let maxHp = -99;
                    let winner = [];
                    this.players.forEach(p => {
                        if (p.hp > maxHp) {
                            maxHp = p.hp;
                            winner = [p.name];
                        } else if (p.hp === maxHp) {
                            winner.push(p.name);
                        }
                    });
                    setTimeout(() => {
                        alert(`GAME SET!\nWinner: ${winner.join(', ')}`);
                        location.reload();
                    }, 500);
                    return true;
                }
                return false;
            }

            phaseCleanup() {
                const getLeftRiverIdx = (i) => (i + 3) % 4;

                for (let i = 0; i < 4; i++) {
                    const card = this.pendingCards[i];
                    const leftRIdx = getLeftRiverIdx(i);

                    if (card === 'M') {
                        if (this.deck.length > 0) {
                            this.rivers[leftRIdx].push(this.deck.pop());
                            this.log(`${PLAYER_NAMES[i]}のM消滅。山札から補充。`);
                        } else {
                            this.log(`${PLAYER_NAMES[i]}のM消滅。山札切れのため補充なし。`);
                        }
                    } else {
                        this.rivers[leftRIdx].push(card);
                    }
                }

                this.startDraftPhase();
            }

            startDraftPhase() {
                this.setPhase('DRAFT');
                
                [0, 1, 3].forEach(i => {
                    const drawRiverIdx = (i + 3) % 4;
                    const river = this.rivers[drawRiverIdx];
                    if (river.length > 0) {
                        const rIdx = Math.floor(Math.random() * river.length);
                        const card = river.splice(rIdx, 1)[0];
                        this.players[i].hand.push(card);
                    }
                });

                const myDrawRiverIdx = (2 + 3) % 4; 
                const myRiver = this.rivers[myDrawRiverIdx];
                
                if (myRiver.length === 0) {
                    this.log("リバーが枯渇しています。補充なし。");
                    this.finishTurn();
                } else {
                    this.showRiverSelection(myRiver);
                }
            }

            showRiverSelection(river) {
                const overlay = document.getElementById('overlay-container');
                const riverArea = document.getElementById('river-selection-area');
                const riverCardsDiv = document.getElementById('river-cards');
                
                // Switch Setup -> River view
                document.getElementById('setup-screen').style.display = 'none';
                overlay.style.display = 'flex';
                riverArea.style.display = 'flex';

                riverCardsDiv.innerHTML = '';
                
                river.forEach((card, index) => {
                    const el = document.createElement('div');
                    el.className = 'card card-back';
                    el.onclick = () => {
                        const drawn = river.splice(index, 1)[0];
                        this.players[2].hand.push(drawn);
                        this.log(`リバーからカードを補充しました。`);
                        overlay.style.display = 'none';
                        riverArea.style.display = 'none';
                        this.finishTurn();
                    };
                    riverCardsDiv.appendChild(el);
                });
            }

            finishTurn() {
                this.isProcessing = false;
                this.setPhase('CHARGE');
                this.updateUI();
            }

            // --- Rendering ---
            renderGrid() {
                const grid = document.getElementById('grid');
                grid.innerHTML = '';
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        if (x === CENTER && y === CENTER) cell.classList.add('center');
                        if (Math.round(this.corePos.x) === x && Math.round(this.corePos.y) === y) {
                            const core = document.createElement('div');
                            core.className = 'core';
                            cell.appendChild(core);
                        }
                        grid.appendChild(cell);
                    }
                }
            }

            renderHand() {
                const container = document.getElementById('hand-container');
                container.innerHTML = '';
                this.players[2].hand.forEach((card, index) => {
                    const el = document.createElement('div');
                    el.className = 'card';
                    el.textContent = card;
                    if (card === 'M') {
                        el.style.color = '#d0f';
                        el.style.borderColor = '#d0f';
                    }
                    if (index === this.selectedCardIndex) el.classList.add('selected');
                    
                    if (!this.isProcessing) {
                        el.onclick = () => this.selectCard(index);
                    } else {
                        el.classList.add('disabled');
                    }
                    container.appendChild(el);
                });
            }

            updateUI() {
                for (let i = 0; i < 4; i++) {
                    const p = this.players[i];
                    const hpEl = document.getElementById(`hp-${i}`);
                    hpEl.textContent = `HP: ${p.hp}`;
                    
                    if (p.hp <= 3) hpEl.style.color = '#ff0000';
                    else hpEl.style.color = '#00d2ff';

                    if(p.hp <= 0) {
                        hpEl.textContent = "DEAD";
                        document.getElementById(i===0?'zone-north':i===1?'zone-east':i===2?'zone-south':'zone-west').style.opacity = 0.5;
                    }
                }
            }

            sendChat() {
                const targetVal = document.getElementById('chat-target').value;
                const msgVal = document.getElementById('chat-msg-select').value;
                let targetName = "全員";
                if(targetVal !== "ALL") targetName = PLAYER_NAMES[parseInt(targetVal)];
                this.showBubble(2, msgVal); 
                this.log(`YOU > ${targetName}: ${msgVal}`);
            }

            showBubble(playerIdx, text) {
                const b = document.getElementById(`bubble-${playerIdx}`);
                b.textContent = text;
                b.classList.add('show');
                setTimeout(() => b.classList.remove('show'), 3000);
            }

            log(msg, type='') {
                const log = document.getElementById('chat-log');
                const div = document.createElement('div');
                div.className = `chat-msg ${type}`;
                div.textContent = msg;
                log.appendChild(div);
                log.scrollTop = log.scrollHeight;
            }
        }

        // Start init
        const game = new SquareForce();
        initSetup();

    </script>
</body>
</html>
